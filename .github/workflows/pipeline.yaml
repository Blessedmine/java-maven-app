name: Java Maven CI_CD

on:
  push:
    branches:
      - main

env:
  IMAGE_NAME: java-maven-app
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Dmaven.repo.local=$HOME/.m2/repository'
  K8S_NAMESPACE: 'default'
  ARGOCD_NAMESPACE: 'argocd'

jobs:
  test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn -B clean compile

      - name: Run Unit Tests
        run: mvn -B test

      - name: Run Integration Tests
        run: mvn -B verify

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'


  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build Package
        run: mvn -B clean package -DskipTests

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: target/*.jar
          retention-days: 7


  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: java-app
          path: target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Minikube with ArgoCD
    runs-on: ubuntu-latest
    needs: docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Minikube
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64

          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl

      - name: Start Minikube cluster
        run: |
          minikube start --driver=docker --memory=4096 --cpus=2
          minikube addons enable metrics-server

      - name: Verify cluster
        run: |
          minikube status
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespaces
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace ${{ env.ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install ArgoCD
        run: |
          kubectl apply -n ${{ env.ARGOCD_NAMESPACE }} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD to be ready
        run: |
          # Wait for ArgoCD deployments to be created
          echo "Waiting for ArgoCD deployments..."
          timeout 180 bash -c 'until kubectl get deployment argocd-server -n ${{ env.ARGOCD_NAMESPACE }} &>/dev/null; do sleep 5; done'
          
          # Wait for deployments to be available
          echo "Waiting for ArgoCD server to be available..."
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-server --timeout=600s
          
          # Wait for other key ArgoCD components
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-repo-server --timeout=300s
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-applicationset-controller --timeout=300s

      - name: Patch ArgoCD service to NodePort
        run: |
          kubectl patch svc argocd-server -n ${{ env.ARGOCD_NAMESPACE }} \
            -p '{"spec": {"type": "NodePort", "ports": [{"port": 443, "targetPort": 8080, "nodePort": 30080}]}}'

      - name: Get ArgoCD admin password
        run: |
          # Wait for the secret to be created
          echo "Waiting for ArgoCD admin secret..."
          until kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret &>/dev/null; do
            echo "Waiting for ArgoCD secret..."
            sleep 10
          done
          
          # Get the password and set as environment variable
          kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d > /tmp/argocd-password
          echo "ARGOCD_PASSWORD=$(cat /tmp/argocd-password)" >> $GITHUB_ENV
          echo "ArgoCD password retrieved successfully"

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64
          echo "ArgoCD CLI installed successfully"

      - name: Configure ArgoCD access
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "ARGOCD_SERVER=$MINIKUBE_IP:30080" >> $GITHUB_ENV
          echo "ArgoCD Server URL: https://$MINIKUBE_IP:30080"
          
          # Wait for ArgoCD to be reachable
          echo "Waiting for ArgoCD server to be reachable..."
          for i in {1..30}; do
            if curl -k -s https://$MINIKUBE_IP:30080 &>/dev/null; then
              echo "âœ… ArgoCD server is ready!"
              break
            fi
            echo "Waiting for ArgoCD server to be ready... ($i/30)"
            sleep 10
          done

      - name: Login to ArgoCD
        run: |
          # Retry login in case server isn't fully ready
          echo "Logging into ArgoCD..."
          for i in {1..10}; do
            if argocd login ${{ env.ARGOCD_SERVER }} \
              --username admin \
              --password ${{ env.ARGOCD_PASSWORD }} \
              --insecure \
              --grpc-web; then
              echo "âœ… Successfully logged into ArgoCD"
              break
            fi
            echo "Login attempt $i failed, retrying..."
            sleep 10
          done

      - name: Update deployment manifest for ArgoCD
        run: |
          # Update the deployment manifest with the new image tag
          sed -i "s|image:.*|image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" manifests/deployment.yaml
          echo "Updated deployment manifest with new image tag"

      - name: Create ArgoCD Application
        run: |
          # Check if app exists, if not create it
          if ! argocd app get ${{ env.IMAGE_NAME }} --grpc-web &>/dev/null; then
            echo "Creating new ArgoCD application..."
            argocd app create ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }}.git \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
            echo "âœ… ArgoCD application created"
          else
            echo "ArgoCD application already exists, updating..."
            # Update the application if it exists
            argocd app set ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }}.git \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
            echo "âœ… ArgoCD application updated"
          fi

      - name: Sync ArgoCD Application
        run: |
          echo "Syncing ArgoCD application..."
          argocd app sync ${{ env.IMAGE_NAME }} --grpc-web --retry-limit 5
          echo "âœ… ArgoCD application sync completed"

      - name: Wait for application rollout via ArgoCD
        run: |
          echo "Waiting for application to be healthy..."
          argocd app wait ${{ env.IMAGE_NAME }} --health --timeout 600 --grpc-web
          echo "âœ… Application is healthy"

      - name: Verify deployment through ArgoCD
        run: |
          echo "=== ArgoCD Application Status ==="
          argocd app get ${{ env.IMAGE_NAME }} --grpc-web
          
          echo "=== Kubernetes Resources ==="
          kubectl get deployments,services,pods -n ${{ env.K8S_NAMESPACE }}
          
          echo "=== Deployment Status ==="
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=300s

      - name: Test application endpoint
        run: |
          # Get the service URL and test the application
          MINIKUBE_IP=$(minikube ip)
          SERVICE_PORT=$(kubectl get service ${{ env.IMAGE_NAME }}-service -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "80")
          echo "Application URL: http://$MINIKUBE_IP:$SERVICE_PORT"
          
          # Wait for application to be ready and test
          echo "Testing application endpoint..."
          for i in {1..30}; do
            if curl -f -s http://$MINIKUBE_IP:$SERVICE_PORT > /dev/null; then
              echo "âœ… Application is responding!"
              curl -s http://$MINIKUBE_IP:$SERVICE_PORT | head -c 100
              break
            fi
            echo "Waiting for application to be ready... ($i/30)"
            sleep 5
          done

      - name: Display ArgoCD UI Access Info
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "ğŸ¯ ArgoCD UI Access Information:"
          echo "ğŸ“± URL: https://$MINIKUBE_IP:30080"
          echo "ğŸ‘¤ Username: admin"
          echo "ğŸ”‘ Password: ${{ env.ARGOCD_PASSWORD }}"
          echo "ğŸ’¡ Use 'kubectl port-forward svc/argocd-server -n argocd 8080:443' for local access"

  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [test, build, docker, deploy]
    if: always()

    steps:
      - name: Workflow Status
        run: |
          if [ "${{ needs.test.result }}" == "success" ] && [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "âœ… CI/CD Pipeline completed successfully"
            echo "ğŸš€ Application deployed to Minikube with ArgoCD"
            echo "ğŸ³ Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
            echo "ğŸ“Š ArgoCD is managing the deployment"
          else
            echo "âŒ CI/CD Pipeline failed"
            echo "Test job: ${{ needs.test.result }}"
            echo "Build job: ${{ needs.build.result }}"
            echo "Docker job: ${{ needs.docker.result }}"
            echo "Deploy job: ${{ needs.deploy.result }}"
            exit 1
          fi