name: Java Maven CI_CD

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'manifests/**'

env:
  IMAGE_NAME: java-maven-app
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Dmaven.repo.local=$HOME/.m2/repository'
  K8S_NAMESPACE: 'default'
  ARGOCD_NAMESPACE: 'argocd'

jobs:
  test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn -B clean compile

      - name: Run Unit Tests
        run: mvn -B test

      - name: Run Integration Tests
        run: mvn -B verify

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'


  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build Package
        run: mvn -B clean package -DskipTests

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: target/*.jar
          retention-days: 7


  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: java-app
          path: target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max


  deploy:
    name: Deploy to Minikube
    runs-on: ubuntu-latest
    needs: docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code with write permissions
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update image in deployment manifest
        run: |
          # Update the deployment manifest with the new image tag
          sed -i "s|image:.*|image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" manifests/deployment.yaml
          
          # Commit the updated manifest
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add manifests/deployment.yaml
          
          # Only commit if there are changes
          if ! git diff --staged --quiet; then
            git commit -m "Update image to ${{ github.sha }}"
            git push
          else
            echo "No changes to commit"
          fi

      - name: Set up Minikube
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64

          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl

      - name: Start Minikube cluster
        run: |
          minikube start --driver=docker --memory=4096 --cpus=2
          minikube addons enable metrics-server

      - name: Verify cluster
        run: |
          minikube status
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install ArgoCD
        run: |
          kubectl create namespace ${{ env.ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n ${{ env.ARGOCD_NAMESPACE }} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD to be ready
        run: |
          # Wait for ArgoCD deployments to be created
          timeout 120 bash -c 'until kubectl get deployment argocd-server -n ${{ env.ARGOCD_NAMESPACE }} &>/dev/null; do sleep 5; done'
          
          # Wait for deployments to be available
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-server --timeout=600s

      - name: Patch ArgoCD service to NodePort
        run: |
          kubectl patch svc argocd-server -n ${{ env.ARGOCD_NAMESPACE }} \
            -p '{"spec": {"type": "NodePort", "ports": [{"port": 443, "targetPort": 8080, "nodePort": 30080}]}}'

      - name: Get ArgoCD admin password
        run: |
          # Wait for the secret to be created
          until kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret &>/dev/null; do
            echo "Waiting for ArgoCD secret..."
            sleep 10
          done
          
          # Get the password and set as environment variable
          kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d > /tmp/argocd-password
          echo "ARGOCD_PASSWORD=$(cat /tmp/argocd-password)" >> $GITHUB_ENV

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: Configure ArgoCD access
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "ARGOCD_SERVER=$MINIKUBE_IP:30080" >> $GITHUB_ENV
          echo "ArgoCD Server URL: https://$MINIKUBE_IP:30080"
          
          # Wait for ArgoCD to be reachable
          for i in {1..30}; do
            if curl -k -s https://$MINIKUBE_IP:30080 &>/dev/null; then
              echo "ArgoCD server is ready!"
              break
            fi
            echo "Waiting for ArgoCD server to be ready... ($i/30)"
            sleep 10
          done

      - name: Login to ArgoCD
        run: |
          # Retry login in case server isn't fully ready
          for i in {1..5}; do
            if argocd login ${{ env.ARGOCD_SERVER }} \
              --username admin \
              --password ${{ env.ARGOCD_PASSWORD }} \
              --insecure \
              --grpc-web; then
              echo "Successfully logged into ArgoCD"
              break
            fi
            echo "Login attempt $i failed, retrying..."
            sleep 10
          done

      - name: Create ArgoCD Application
        run: |
          # Check if app exists, if not create it
          if ! argocd app get ${{ env.IMAGE_NAME }} --grpc-web &>/dev/null; then
            echo "Creating new ArgoCD application"
            argocd app create ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }}.git \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
          else
            echo "ArgoCD application already exists"
          fi

      - name: Sync ArgoCD Application
        run: |
          argocd app sync ${{ env.IMAGE_NAME }} --grpc-web --retry-limit 5

      - name: Wait for application rollout
        run: |
          argocd app wait ${{ env.IMAGE_NAME }} --health --timeout 600 --grpc-web

      - name: Verify deployment
        run: |
          echo "=== Checking deployments ==="
          kubectl get deployments -n ${{ env.K8S_NAMESPACE }}
          
          echo "=== Checking services ==="
          kubectl get services -n ${{ env.K8S_NAMESPACE }}
          
          echo "=== Checking pods ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          
          echo "=== Checking rollout status ==="
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=300s
 

  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [test, build, docker, deploy]
    if: always()

    steps:
      - name: Workflow Status
        run: |
          if [ "${{ needs.test.result }}" == "success" ] && [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ CI/CD Pipeline completed successfully"
            echo "Application deployed to Minikube with ArgoCD"
          else
            echo "❌ CI/CD Pipeline failed"
            echo "Test job: ${{ needs.test.result }}"
            echo "Build job: ${{ needs.build.result }}"
            echo "Docker job: ${{ needs.docker.result }}"
            echo "Deploy job: ${{ needs.deploy.result }}"
            exit 1
          fi