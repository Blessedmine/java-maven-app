name: Java Maven CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  IMAGE_NAME: java-maven-app
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Dmaven.repo.local=$HOME/.m2/repository'
  K8S_NAMESPACE: 'default'
  ARGOCD_NAMESPACE: 'argocd'

jobs:
  test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn -B clean compile

      - name: Run Unit Tests
        run: mvn -B test

      - name: Run Integration Tests
        run: mvn -B verify

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            target/surefire-reports/
            target/failsafe-reports/
          retention-days: 7

  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build Package
        run: mvn -B clean package -DskipTests

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: target/*.jar
          retention-days: 7

  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: java-app
          path: target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

  deploy:
    name: Deploy to Minikube
    runs-on: ubuntu-latest
    needs: docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Docker
        run: |
          sudo apt-get update
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo usermod -aG docker $USER

      - name: Install Minikube
        run: |
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl

      - name: Start Minikube cluster
        run: |
          sudo minikube start --driver=docker --memory=4096 --cpus=2
          minikube addons enable metrics-server

      - name: Verify cluster
        run: |
          minikube status
          kubectl cluster-info
          kubectl get nodes

      - name: Install ArgoCD
        run: |
          kubectl create namespace ${{ env.ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n ${{ env.ARGOCD_NAMESPACE }} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD
        run: |
          timeout 300 bash -c 'until kubectl get deployment argocd-server -n ${{ env.ARGOCD_NAMESPACE }} &>/dev/null; do sleep 5; done'
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-server --timeout=600s

      - name: Patch ArgoCD service
        run: |
          kubectl patch svc argocd-server -n ${{ env.ARGOCD_NAMESPACE }} \
            -p '{"spec": {"type": "NodePort", "ports": [{"port": 443, "targetPort": 8080, "nodePort": 30080}]}}'

      - name: Get ArgoCD admin password
        run: |
          # Wait for the secret to be created
          until kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret &>/dev/null; do
            echo "Waiting for ArgoCD secret..."
            sleep 10
          done
          # Get the password and set as environment variable
          kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d > /tmp/argocd-password
          echo "ARGOCD_PASSWORD=$(cat /tmp/argocd-password)" >> $GITHUB_ENV

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: Configure ArgoCD access
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "ARGOCD_SERVER=$MINIKUBE_IP:30080" >> $GITHUB_ENV
          echo "ArgoCD Server: $MINIKUBE_IP:30080"
          
          # Wait for ArgoCD to be reachable
          for i in {1..30}; do
            if curl -k -s https://$MINIKUBE_IP:30080 | grep -q "Argo CD"; then
              echo "ArgoCD server is ready!"
              break
            fi
            echo "Waiting for ArgoCD server to be ready... ($i/30)"
            sleep 10
          done

      - name: Login to ArgoCD
        run: |
          argocd login ${{ env.ARGOCD_SERVER }} \
            --username admin \
            --password ${{ env.ARGOCD_PASSWORD }} \
            --insecure \
            --grpc-web \
            --skip-test-tls

      - name: Create or Update ArgoCD Application
        run: |
          # Check if app exists
          if argocd app get ${{ env.IMAGE_NAME }} --grpc-web &>/dev/null; then
            echo "Updating existing ArgoCD application"
            argocd app set ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }} \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
          else
            echo "Creating new ArgoCD application"
            argocd app create ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }} \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
          fi

      - name: Sync ArgoCD Application
        run: |
          argocd app sync ${{ env.IMAGE_NAME }} --grpc-web --retry-limit 5

      - name: Wait for application rollout
        run: |
          argocd app wait ${{ env.IMAGE_NAME }} --health --timeout 600 --grpc-web

      - name: Verify deployment
        run: |
          kubectl get deployments,services,pods -n ${{ env.K8S_NAMESPACE }}

  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [test, build, docker, deploy]
    if: always()

    steps:
      - name: Workflow Status
        run: |
          echo "Test Job: ${{ needs.test.result }}"
          echo "Build Job: ${{ needs.build.result }}"
          echo "Docker Job: ${{ needs.docker.result }}"
          echo "Deploy Job: ${{ needs.deploy.result }}"