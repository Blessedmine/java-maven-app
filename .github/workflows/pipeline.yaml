name: Java Maven CI/CD

on:
  push:
    branches:
      - main

env:
  IMAGE_NAME: java-maven-app
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Dmaven.repo.local=$HOME/.m2/repository'
  K8S_NAMESPACE: 'default'
  ARGOCD_NAMESPACE: 'argocd'

jobs:
  test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn -B clean compile

      - name: Run Unit Tests
        run: mvn -B test

      - name: Run Integration Tests
        run: mvn -B verify

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build Package
        run: mvn -B clean package -DskipTests

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: target/*.jar
          retention-days: 7

  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: java-app
          path: target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Minikube
    runs-on: ubuntu-latest
    needs: docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Minikube
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64

          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl

      - name: Start Minikube cluster
        run: |
          minikube start --driver=docker --memory=4096 --cpus=2
          minikube addons enable metrics-server

      - name: Verify cluster
        run: |
          minikube status
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Update and apply Kubernetes manifests
        run: |
          # Update the deployment manifest with the new image tag
          sed -i "s|image:.*|image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" manifests/deployment.yaml
          
          # Apply the manifests directly to Kubernetes
          echo "Applying Kubernetes manifests..."
          kubectl apply -f manifests/ -n ${{ env.K8S_NAMESPACE }}
          
          # Wait for rollout to complete
          echo "Waiting for deployment rollout..."
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=300s

      - name: Verify deployment
        run: |
          echo "=== Deployment Details ==="
          kubectl get deployment ${{ env.IMAGE_NAME }} -n ${{ env.K8S_NAMESPACE }} -o wide
          
          echo "=== Service Details ==="
          kubectl get service ${{ env.IMAGE_NAME }}-service -n ${{ env.K8S_NAMESPACE }} -o wide
          
          echo "=== Pod Details ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.IMAGE_NAME }}
          
          echo "=== Pod Logs ==="
          kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.IMAGE_NAME }} --tail=10

      - name: Test application
        run: |
          # Get the service URL and test the application
          MINIKUBE_IP=$(minikube ip)
          SERVICE_PORT=$(kubectl get service ${{ env.IMAGE_NAME }}-service -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
          echo "Application URL: http://$MINIKUBE_IP:$SERVICE_PORT"
          
          # Wait for application to be ready and test
          echo "Testing application endpoint..."
          for i in {1..30}; do
            if curl -s http://$MINIKUBE_IP:$SERVICE_PORT > /dev/null; then
              echo "✅ Application is responding!"
              break
            fi
            echo "Waiting for application to be ready... ($i/30)"
            sleep 5
          done

  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [test, build, docker, deploy]
    if: always()

    steps:
      - name: Workflow Status
        run: |
          if [ "${{ needs.test.result }}" == "success" ] && [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ CI/CD Pipeline completed successfully"
            echo "Application deployed to Minikube"
            echo "Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          else
            echo "❌ CI/CD Pipeline failed"
            echo "Test job: ${{ needs.test.result }}"
            echo "Build job: ${{ needs.build.result }}"
            echo "Docker job: ${{ needs.docker.result }}"
            echo "Deploy job: ${{ needs.deploy.result }}"
            exit 1
          fi