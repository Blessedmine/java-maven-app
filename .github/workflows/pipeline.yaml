name: Java Maven CI_CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  IMAGE_NAME: java-maven-app
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Dmaven.repo.local=$HOME/.m2/repository'
  K8S_NAMESPACE: 'default'
  ARGOCD_NAMESPACE: 'argocd'

jobs:
  test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven
        run: mvn -B clean compile

      - name: Run Unit Tests
        run: mvn -B test

      - name: Run Integration Tests
        run: mvn -B verify

      - name: Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            target/surefire-reports/
            target/failsafe-reports/
          retention-days: 7

  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build Package
        run: mvn -B clean package -DskipTests

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: java-app
          path: target/*.jar
          retention-days: 7

  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: java-app
          path: target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

  deploy:
    name: Deploy to Minikube
    runs-on: ubuntu-latest
    needs: docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Kubernetes manifests if they don't exist
        run: |
          # Create manifests directory if it doesn't exist
          mkdir -p manifests
          
          # Create deployment.yaml if it doesn't exist
          if [ ! -f manifests/deployment.yaml ]; then
            cat > manifests/deployment.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.IMAGE_NAME }}
            namespace: ${{ env.K8S_NAMESPACE }}
            labels:
              app: ${{ env.IMAGE_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.IMAGE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.IMAGE_NAME }}
              spec:
                containers:
                - name: ${{ env.IMAGE_NAME }}
                  image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
                  ports:
                  - containerPort: 8080
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /actuator/health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /actuator/health
                      port: 8080
                    initialDelaySeconds: 5
                    periodSeconds: 5
          EOF
          fi

          # Create service.yaml if it doesn't exist
          if [ ! -f manifests/service.yaml ]; then
            cat > manifests/service.yaml << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.IMAGE_NAME }}-service
            namespace: ${{ env.K8S_NAMESPACE }}
          spec:
            selector:
              app: ${{ env.IMAGE_NAME }}
            ports:
            - port: 80
              targetPort: 8080
            type: ClusterIP
          EOF
          fi

          # Create kustomization.yaml if it doesn't exist
          if [ ! -f manifests/kustomization.yaml ]; then
            cat > manifests/kustomization.yaml << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources:
          - deployment.yaml
          - service.yaml
          EOF
          fi

          # Show created files
          ls -la manifests/

      - name: Set up Minikube
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64

          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl

      - name: Start Minikube with Docker driver
        run: |
          # Start Minikube using the pre-installed Docker
          minikube start --driver=docker --memory=4096 --cpus=2
          minikube addons enable metrics-server

      - name: Verify cluster
        run: |
          minikube status
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install ArgoCD
        run: |
          kubectl create namespace ${{ env.ARGOCD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n ${{ env.ARGOCD_NAMESPACE }} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD
        run: |
          # Wait for ArgoCD to be ready
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=available deployment/argocd-server --timeout=600s
          kubectl wait -n ${{ env.ARGOCD_NAMESPACE }} --for=condition=ready pod -l app.kubernetes.io/name=argocd-server --timeout=300s

      - name: Patch ArgoCD service
        run: |
          kubectl patch svc argocd-server -n ${{ env.ARGOCD_NAMESPACE }} \
            -p '{"spec": {"type": "NodePort", "ports": [{"port": 443, "targetPort": 8080, "nodePort": 30080}]}}'

      - name: Get ArgoCD admin password
        run: |
          # Wait for the secret to be created
          until kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret &>/dev/null; do
            echo "Waiting for ArgoCD secret..."
            sleep 10
          done
          # Get the password
          kubectl get secret -n ${{ env.ARGOCD_NAMESPACE }} argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d > /tmp/argocd-password
          echo "ARGOCD_PASSWORD=$(cat /tmp/argocd-password)" >> $GITHUB_ENV

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: Configure ArgoCD access
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "ARGOCD_SERVER=$MINIKUBE_IP:30080" >> $GITHUB_ENV
          echo "ArgoCD Server: $MINIKUBE_IP:30080"
          
          # Wait for ArgoCD to be reachable
          for i in {1..30}; do
            if curl -k -s https://$MINIKUBE_IP:30080 &>/dev/null; then
              echo "ArgoCD server is ready!"
              break
            fi
            echo "Waiting for ArgoCD server to be ready... ($i/30)"
            sleep 10
          done

      - name: Login to ArgoCD
        run: |
          # Retry login in case server isn't fully ready
          for i in {1..5}; do
            if argocd login ${{ env.ARGOCD_SERVER }} \
              --username admin \
              --password ${{ env.ARGOCD_PASSWORD }} \
              --insecure \
              --grpc-web; then
              echo "Successfully logged into ArgoCD"
              break
            fi
            echo "Login attempt $i failed, retrying..."
            sleep 10
          done

      - name: Create ArgoCD Application
        run: |
          # Check if app exists, if not create it
          if ! argocd app get ${{ env.IMAGE_NAME }} --grpc-web &>/dev/null; then
            echo "Creating new ArgoCD application"
            argocd app create ${{ env.IMAGE_NAME }} \
              --repo https://github.com/${{ github.repository }} \
              --path manifests \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace ${{ env.K8S_NAMESPACE }} \
              --sync-policy automated \
              --auto-prune \
              --self-heal \
              --grpc-web
          else
            echo "ArgoCD application already exists"
          fi

      - name: Sync ArgoCD Application
        run: |
          argocd app sync ${{ env.IMAGE_NAME }} --grpc-web --retry-limit 5

      - name: Wait for application rollout
        run: |
          argocd app wait ${{ env.IMAGE_NAME }} --health --timeout 600 --grpc-web

      - name: Verify deployment
        run: |
          kubectl get deployments,services,pods -n ${{ env.K8S_NAMESPACE }}
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.K8S_NAMESPACE }} --timeout=300s

  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [test, build, docker, deploy]
    if: always()

    steps:
      - name: Workflow Status
        run: |
          if [ "${{ needs.test.result }}" == "success" ] && [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ CI/CD Pipeline completed successfully"
          else
            echo "❌ CI/CD Pipeline failed"
            echo "Test: ${{ needs.test.result }}"
            echo "Build: ${{ needs.build.result }}"
            echo "Docker: ${{ needs.docker.result }}"
            echo "Deploy: ${{ needs.deploy.result }}"
            exit 1
          fi